easyClose = TRUE
))
} else if (polygon_missing) {
showModal(modalDialog(
title = "Image Annotation Required",
"Please highlight a region in the picture before proceeding to the next page.",
easyClose = TRUE
))
} else {
annotated_img_name <- paste0("annotated_", input_filename, "_", selected_class, ".jpg")
annotation_csv_name <- paste0("annotated_", input_filename, "_", selected_class, ".csv")
# Adjust Y-coordinates before saving in CSV
img <- image_read(selected_images[i])
img_height <- image_info(img)$height
annotation_data <- polygon_coords %>%
select(-name) %>%
mutate(
x = x,                             # X-coordinates remain the same
y = img_height - y,                # Adjust Y-coordinates
image_id = i,
class_selected = selected_class,
class_AI = class_AI
)
write_csv(annotation_data, path = file.path("annotiert_polygon_table", annotation_csv_name))
img <- image_read(selected_images[i])
img_width <- image_info(img)$width
img_height <- image_info(img)$height
# Scale polygon coordinates based on original image dimensions
img_with_polygon <- image_draw(img)
unique_polygons <- unique(polygon_coords$polygon_id)
for (poly_id in unique_polygons) {
poly_coords <- polygon_coords %>% filter(polygon_id == poly_id)
x_scaled <- poly_coords$x * (img_width / 500)
y_scaled <- poly_coords$y * (img_height / 500)
polygon(x_scaled, img_height - y_scaled, border = "blue", col = rgb(0, 0, 1, alpha = 0.2))
}
dev.off()
image_write(img_with_polygon, path = file.path("annotiert_xai_image", annotated_img_name))
page(current_page + 1)
}
} else {
page(current_page + 1)
}
})
}
shinyApp(ui, server)
# install.packages("imager")
library(imager)
library(dplyr)
library(readr)
library(ggplot2)
# Directories for input and output
annotations_dir <- '/content/annotiert_polygon_table'  # Folder containing CSV files
images_dir <- '/content/org_image'                     # Folder containing image files in .png format
output_dir_1 <- '/content/annotiert_blank_pixel_image' # Folder to save blank images with colored pixels
output_dir_2 <- '/content/annotiert_aus_polygon_image' # Folder to save images with polygons drawn
output_dir_3 <- '/content/annotiert_pixel_table'       # Folder to save pixel data CSVs
# Ensure the output directory exists
if (!dir.exists(output_dir_1)) dir.create(output_dir_1)
if (!dir.exists(output_dir_2)) dir.create(output_dir_2)
if (!dir.exists(output_dir_3)) dir.create(output_dir_3)
# Process each CSV file in the annotations directory
csv_files <- list.files(annotations_dir, pattern = '\\.csv$', full.names = TRUE)
for (csv_file in csv_files) {
# Get the base name without extension
base_name <- tools::file_path_sans_ext(basename(csv_file))
cat("Processing:", base_name, "\n")
# Remove part after the second last underscore
image_base_name <- gsub("_(?:[^_]*$|[^_]*_[^_]*$)", "", base_name)
# Remove 'annotated_' prefix if it exists
image_base_name <- sub("^annotated_", "", image_base_name)
# Define paths for the CSV and the corresponding image
csv_path <- file.path(annotations_dir, csv_file)
image_path <- file.path(images_dir, paste0(image_base_name, '.png'))
# Check if the corresponding image file exists
if (!file.exists(image_path)) {
cat("Image file not found, skipping...\n")
next
}
# Load CSV data
polygon_data <- read_csv(csv_path) %>%
mutate(across(c(x, y), as.numeric)) %>%
drop_na()
# Load the image
image <- load.image(image_path)
height <- dim(image)[1]
width <- dim(image)[2]
all_pixels <- data.frame()  # Data frame to store pixel data
# Process each polygon in the CSV file
unique_polygons <- unique(polygon_data$polygon_id)
for (polygon_id in unique_polygons) {
polygon_points <- polygon_data %>%
filter(polygon_id == polygon_id) %>%
select(x, y)
# Create a mask with the polygon
mask <- matrix(0, height, width)
points <- as.matrix(polygon_points)
poly <- as.polygon(points)
mask[poly] <- 1
# Find pixels inside the polygon and store pixel data
indices <- which(mask == 1, arr.ind = TRUE)
pixels <- data.frame(x = indices[, 2], y = indices[, 1], polygon_id = polygon_id)
all_pixels <- bind_rows(all_pixels, pixels)
# Draw polygon on the image
plot(image)
lines(poly$x, poly$y, col = 'red', lwd = 2)
}
# Define output paths
output_csv_path <- file.path(output_dir_3, paste0(base_name, "_pixel_table.csv"))
output_image_path <- file.path(output_dir_2, paste0(base_name, "_aus_polygon_image.png"))
output_blank_image_path <- file.path(output_dir_1, paste0(base_name, "_blank_pixel_image.png"))
# Save pixel data to CSV file
write_csv(all_pixels, output_csv_path)
cat("Pixel data saved to", output_csv_path, "\n")
# Save image with polygons
save.image(image, output_image_path)
cat("Image with polygons saved to", output_image_path, "\n")
# Create and save blank image with colored pixels
blank_image <- imfill(width, height, val = c(0, 0, 0))  # Black background
for (i in 1:nrow(all_pixels)) {
x <- all_pixels$x[i]
y <- all_pixels$y[i]
blank_image[x, y, 1] <- 1  # Set pixel to red
}
# Save blank image with colored pixels
save.image(blank_image, output_blank_image_path)
cat("Blank image with colored pixels saved to", output_blank_image_path, "\n")
}
# install.packages("imager")
library(imager)
library(dplyr)
library(readr)
library(ggplot2)
# Directories for input and output
annotations_dir <- '/annotiert_polygon_table'  # Folder containing CSV files
images_dir <- '/org_image'                     # Folder containing image files in .png format
output_dir_1 <- '/annotiert_blank_pixel_image' # Folder to save blank images with colored pixels
output_dir_2 <- '/annotiert_aus_polygon_image' # Folder to save images with polygons drawn
output_dir_3 <- '/annotiert_pixel_table'       # Folder to save pixel data CSVs
# Ensure the output directory exists
if (!dir.exists(output_dir_1)) dir.create(output_dir_1)
if (!dir.exists(output_dir_2)) dir.create(output_dir_2)
if (!dir.exists(output_dir_3)) dir.create(output_dir_3)
# Process each CSV file in the annotations directory
csv_files <- list.files(annotations_dir, pattern = '\\.csv$', full.names = TRUE)
for (csv_file in csv_files) {
# Get the base name without extension
base_name <- tools::file_path_sans_ext(basename(csv_file))
cat("Processing:", base_name, "\n")
# Remove part after the second last underscore
image_base_name <- gsub("_(?:[^_]*$|[^_]*_[^_]*$)", "", base_name)
# Remove 'annotated_' prefix if it exists
image_base_name <- sub("^annotated_", "", image_base_name)
# Define paths for the CSV and the corresponding image
csv_path <- file.path(annotations_dir, csv_file)
image_path <- file.path(images_dir, paste0(image_base_name, '.png'))
# Check if the corresponding image file exists
if (!file.exists(image_path)) {
cat("Image file not found, skipping...\n")
next
}
# Load CSV data
polygon_data <- read_csv(csv_path) %>%
mutate(across(c(x, y), as.numeric)) %>%
drop_na()
# Load the image
image <- load.image(image_path)
height <- dim(image)[1]
width <- dim(image)[2]
all_pixels <- data.frame()  # Data frame to store pixel data
# Process each polygon in the CSV file
unique_polygons <- unique(polygon_data$polygon_id)
for (polygon_id in unique_polygons) {
polygon_points <- polygon_data %>%
filter(polygon_id == polygon_id) %>%
select(x, y)
# Create a mask with the polygon
mask <- matrix(0, height, width)
points <- as.matrix(polygon_points)
poly <- as.polygon(points)
mask[poly] <- 1
# Find pixels inside the polygon and store pixel data
indices <- which(mask == 1, arr.ind = TRUE)
pixels <- data.frame(x = indices[, 2], y = indices[, 1], polygon_id = polygon_id)
all_pixels <- bind_rows(all_pixels, pixels)
# Draw polygon on the image
plot(image)
lines(poly$x, poly$y, col = 'red', lwd = 2)
}
# Define output paths
output_csv_path <- file.path(output_dir_3, paste0(base_name, "_pixel_table.csv"))
output_image_path <- file.path(output_dir_2, paste0(base_name, "_aus_polygon_image.png"))
output_blank_image_path <- file.path(output_dir_1, paste0(base_name, "_blank_pixel_image.png"))
# Save pixel data to CSV file
write_csv(all_pixels, output_csv_path)
cat("Pixel data saved to", output_csv_path, "\n")
# Save image with polygons
save.image(image, output_image_path)
cat("Image with polygons saved to", output_image_path, "\n")
# Create and save blank image with colored pixels
blank_image <- imfill(width, height, val = c(0, 0, 0))  # Black background
for (i in 1:nrow(all_pixels)) {
x <- all_pixels$x[i]
y <- all_pixels$y[i]
blank_image[x, y, 1] <- 1  # Set pixel to red
}
# Save blank image with colored pixels
save.image(blank_image, output_blank_image_path)
cat("Blank image with colored pixels saved to", output_blank_image_path, "\n")
}
# install.packages("imager")
library(imager)
library(dplyr)
library(readr)
library(ggplot2)
# Directories for input and output
annotations_dir <- '/annotiert_polygon_table'  # Folder containing CSV files
images_dir <- '/org_image'                     # Folder containing image files in .png format
output_dir_1 <- '/annotiert_blank_pixel_image' # Folder to save blank images with colored pixels
output_dir_2 <- '/annotiert_aus_polygon_image' # Folder to save images with polygons drawn
output_dir_3 <- '/annotiert_pixel_table'       # Folder to save pixel data CSVs
# Process each CSV file in the annotations directory
csv_files <- list.files(annotations_dir, pattern = '\\.csv$', full.names = TRUE)
for (csv_file in csv_files) {
# Get the base name without extension
base_name <- tools::file_path_sans_ext(basename(csv_file))
cat("Processing:", base_name, "\n")
# Remove part after the second last underscore
image_base_name <- gsub("_(?:[^_]*$|[^_]*_[^_]*$)", "", base_name)
# Remove 'annotated_' prefix if it exists
image_base_name <- sub("^annotated_", "", image_base_name)
# Define paths for the CSV and the corresponding image
csv_path <- file.path(annotations_dir, csv_file)
image_path <- file.path(images_dir, paste0(image_base_name, '.png'))
# Check if the corresponding image file exists
if (!file.exists(image_path)) {
cat("Image file not found, skipping...\n")
next
}
# Load CSV data
polygon_data <- read_csv(csv_path) %>%
mutate(across(c(x, y), as.numeric)) %>%
drop_na()
# Load the image
image <- load.image(image_path)
height <- dim(image)[1]
width <- dim(image)[2]
all_pixels <- data.frame()  # Data frame to store pixel data
# Process each polygon in the CSV file
unique_polygons <- unique(polygon_data$polygon_id)
for (polygon_id in unique_polygons) {
polygon_points <- polygon_data %>%
filter(polygon_id == polygon_id) %>%
select(x, y)
# Create a mask with the polygon
mask <- matrix(0, height, width)
points <- as.matrix(polygon_points)
poly <- as.polygon(points)
mask[poly] <- 1
# Find pixels inside the polygon and store pixel data
indices <- which(mask == 1, arr.ind = TRUE)
pixels <- data.frame(x = indices[, 2], y = indices[, 1], polygon_id = polygon_id)
all_pixels <- bind_rows(all_pixels, pixels)
# Draw polygon on the image
plot(image)
lines(poly$x, poly$y, col = 'red', lwd = 2)
}
# Define output paths
output_csv_path <- file.path(output_dir_3, paste0(base_name, "_pixel_table.csv"))
output_image_path <- file.path(output_dir_2, paste0(base_name, "_aus_polygon_image.png"))
output_blank_image_path <- file.path(output_dir_1, paste0(base_name, "_blank_pixel_image.png"))
# Save pixel data to CSV file
write_csv(all_pixels, output_csv_path)
cat("Pixel data saved to", output_csv_path, "\n")
# Save image with polygons
save.image(image, output_image_path)
cat("Image with polygons saved to", output_image_path, "\n")
# Create and save blank image with colored pixels
blank_image <- imfill(width, height, val = c(0, 0, 0))  # Black background
for (i in 1:nrow(all_pixels)) {
x <- all_pixels$x[i]
y <- all_pixels$y[i]
blank_image[x, y, 1] <- 1  # Set pixel to red
}
# Save blank image with colored pixels
save.image(blank_image, output_blank_image_path)
cat("Blank image with colored pixels saved to", output_blank_image_path, "\n")
}
library(shiny)
library(magick)
library(shinyjs)
library(readr)
library(tidyverse)
ui <- fluidPage(
useShinyjs(),
tags$head(
tags$style(HTML("
body {
font-family: Arial, sans-serif;
background-color: #f5f7fa;
color: #333;
}
h3 {
font-weight: bold;
color: #2c3e50;
}
.main-container {
max-width: 800px;
margin: 0 auto;
padding: 20px;
}
.image-container {
display: flex;
flex-direction: column;
align-items: center;
background-color: #ffffff;
padding: 20px;
border-radius: 8px;
box-shadow: 0px 0px 12px rgba(0, 0, 0, 0.1);
}
.btn-primary, .btn-secondary {
color: #ffffff !important;
border: none;
padding: 10px 20px;
font-size: 16px;
border-radius: 4px;
}
.btn-primary {
background-color: #3498db;
}
.btn-secondary {
background-color: #95a5a6;
}
.select-input {
margin-top: 15px;
font-size: 16px;
}
"))
),
div(class = "main-container",
uiOutput("page_content")
)
)
server <- function(input, output, session) {
if (!dir.exists("annotiert_xai_image")) dir.create("annotiert_xai_image")
if (!dir.exists("annotiert_polygon_table")) dir.create("annotiert_polygon_table")
img_dir <- "xai_image/"
all_images <- list.files(img_dir, pattern = "\\.png$", full.names = TRUE)
selected_images <- sample(all_images, 10)
extract_class_from_filename <- function(filename) {
parts <- strsplit(basename(filename), "_")[[1]]
class_name <- parts[length(parts)]
class_name <- gsub("\\.png", "", class_name)
return(class_name)
}
page <- reactiveVal(1)
coords <- reactiveVal(value = tibble(x = numeric(), y = numeric(), polygon_id = integer(), name = character()))
polygon_id <- reactiveVal(1)
output$page_content <- renderUI({
current_page <- page()
if (current_page == 1) {
tagList(
h3("Welcome to the Random Image Marker Tool"),
p("Use this tool to annotate images by selecting the displayed city and highlighting the region that influenced your decision."),
div(style = "text-align: right; margin-top: 20px;",
actionButton("next_page", "Start Annotating", icon = icon("arrow-right"), class = "btn-primary")
)
)
} else if (current_page >= 2 && current_page <= 11) {
i <- current_page - 1
class_number <- extract_class_from_filename(selected_images[i])
image <- image_read(selected_images[i])
tagList(
div(class = "image-container",
fluidRow(
column(6,
div(style = "text-align: left; margin-top: 20px;",
h4("AI Prediction: ", class_number),
p("Do you agree? Choose the city and highlight the area most important for your decision."),
div(style = "margin-top: 15px;",
div(class = "select-input",
selectInput(paste0("class_", i), NULL,
choices = c("", "Tel Aviv", "Jerusalem", "Hamburg", "Berlin"))
)
)
)
),
column(6,
div(style = "text-align: left;",
plotOutput(paste0("imagePlot", i), click = paste0("image_click_", i), height = "500px")),
div(style = "display: flex; gap: 10px; margin-top: 10px;",
actionButton(paste0("clear_", i), "Clear Annotations", icon = icon("trash"), class = "btn-secondary"),
actionButton(paste0("end_polygon_", i), "Complete Polygon", icon = icon("check"), class = "btn-secondary")
)
)
)
),
div(
actionButton("next_page", "", icon = icon("arrow-right"), class = "btn-primary"),
style = "text-align: right; margin-top: 20px;"
)
)
} else {
tagList(
h3("Thank you for completing the annotations!"),
p("All annotated images and coordinates have been saved."),
actionButton("close_app", "Close", class = "btn-primary", style = "margin-top: 20px;")
)
}
})
observeEvent(page(), {
lapply(1:10, function(i) {
observeEvent(input[[paste0("image_click_", i)]], {
current_coords <- coords()
polygon_id_val <- polygon_id()
current_coords <- add_row(
current_coords,
x = input[[paste0("image_click_", i)]]$x,
y = input[[paste0("image_click_", i)]]$y,
polygon_id = polygon_id_val,
name = paste("polygon", i)
)
coords(current_coords)
})
output[[paste0("imagePlot", i)]] <- renderPlot({
img <- image_read(selected_images[i])
img_raster <- as.raster(img)
plot(img_raster)
all_polygons <- coords() %>% filter(name == paste("polygon", i))
unique_polygons <- unique(all_polygons$polygon_id)
for (poly_id in unique_polygons) {
polygon_coords <- all_polygons %>% filter(polygon_id == poly_id)
if (nrow(polygon_coords) > 2) {
polygon(polygon_coords$x, polygon_coords$y, border = "blue", col = rgb(0, 0, 1, alpha = 0.2))
}
}
})
observeEvent(input[[paste0("clear_", i)]], {
coords(coords() %>% filter(name != paste("polygon", i)))
})
observeEvent(input[[paste0("end_polygon_", i)]], {
polygon_id(polygon_id() + 1)
})
})
})
observeEvent(input$next_page, {
current_page <- page()
if (current_page >= 2 && current_page <= 11) {
i <- current_page - 1
selected_class <- input[[paste0("class_", i)]]
input_filename <- tools::file_path_sans_ext(basename(selected_images[i]))
# Extract class_AI from the filename
class_AI <- extract_class_from_filename(selected_images[i])
annotation_missing <- selected_class == ""
polygon_coords <- coords() %>% filter(name == paste("polygon", i))
polygon_missing <- nrow(polygon_coords) < 3
if (annotation_missing && polygon_missing) {
showModal(modalDialog(
title = "Annotation Required",
"Please select a city from the dropdown menu and highlight a region in the picture before proceeding to the next page.",
easyClose = TRUE
))
} else if (annotation_missing) {
showModal(modalDialog(
title = "Dropdown Selection Required",
"Please select a city from the dropdown menu before proceeding to the next page.",
easyClose = TRUE
))
} else if (polygon_missing) {
showModal(modalDialog(
title = "Image Annotation Required",
"Please highlight a region in the picture before proceeding to the next page.",
easyClose = TRUE
))
} else {
annotated_img_name <- paste0("annotated_", input_filename, "_", selected_class, ".jpg")
annotation_csv_name <- paste0("annotated_", input_filename, "_", selected_class, ".csv")
# Adjust Y-coordinates before saving in CSV
img <- image_read(selected_images[i])
img_height <- image_info(img)$height
annotation_data <- polygon_coords %>%
select(-name) %>%
mutate(
x = x,                             # X-coordinates remain the same
y = img_height - y,                # Adjust Y-coordinates
image_id = i,
class_selected = selected_class,
class_AI = class_AI
)
write_csv(annotation_data, path = file.path("annotiert_polygon_table", annotation_csv_name))
img <- image_read(selected_images[i])
img_width <- image_info(img)$width
img_height <- image_info(img)$height
# Scale polygon coordinates based on original image dimensions
img_with_polygon <- image_draw(img)
unique_polygons <- unique(polygon_coords$polygon_id)
for (poly_id in unique_polygons) {
poly_coords <- polygon_coords %>% filter(polygon_id == poly_id)
x_scaled <- poly_coords$x * (img_width / 500)
y_scaled <- poly_coords$y * (img_height / 500)
polygon(x_scaled, img_height - y_scaled, border = "blue", col = rgb(0, 0, 1, alpha = 0.2))
}
dev.off()
image_write(img_with_polygon, path = file.path("annotiert_xai_image", annotated_img_name))
page(current_page + 1)
}
} else {
page(current_page + 1)
}
})
}
shinyApp(ui, server)
